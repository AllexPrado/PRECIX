# ==== INÍCIO DOS IMPORTS ÚNICOS ====
import os
import json
import io
import sys
import shutil
from database_agents import get_all_agents_status
# ==== INÍCIO DOS IMPORTS ÚNICOS ====
import os
import json
import io
import sys
import shutil
import threading
import time
import requests
from datetime import datetime
from fastapi import FastAPI, HTTPException, UploadFile, File, Request, Body, Depends, Query
from typing import List, Dict
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, JSONResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from database import get_product_by_barcode, init_db, populate_example_data, get_db_connection, authenticate_admin, get_system_status, export_products_to_txt, get_all_stores, add_store, update_store, delete_store, get_all_devices, add_device, update_device, delete_device, set_device_online, set_device_offline, add_audit_log, get_audit_logs, get_device_audit_logs, upsert_agent_status, get_all_agents_status, upsert_products
from static_middleware import mount_frontend
from ai_agent_integration import notify_ai_agent
from ia_event_log import router as ia_event_router
from auth_jwt import create_access_token, verify_access_token
from backup_restore import router as backup_restore_router
from device_store_router import router as device_store_router
from importador_precos import importar_todos_precos
from integration_config import create_integration_table, upsert_integration, get_integrations
# ==== FIM DOS IMPORTS ÚNICOS ====

# Inicializa tabela de integrações ao iniciar o backend
create_integration_table()

# Logs de importação
_import_logs = []
class ImportLogCatcher(io.StringIO):
    def write(self, txt):
        super().write(txt)
        _import_logs.append(txt)
        if len(_import_logs) > 100:
            _import_logs.pop(0)
_old_stdout = sys.stdout
sys.stdout = ImportLogCatcher()

# Diretório público do frontend
FRONTEND_PUBLIC_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'frontend', 'public'))


# Criação única do app
app = FastAPI()
app.include_router(ia_event_router)
app.include_router(backup_restore_router)
app.include_router(device_store_router)
security = HTTPBearer()

# --- Endpoint para agentes locais ---
@app.get('/admin/agents')
def listar_agentes():
    return get_all_agents_status()
security = HTTPBearer()

# Inclusão dos routers
app.include_router(ia_event_router)
app.include_router(backup_restore_router)
app.include_router(device_store_router)

# Endpoints de importação de preços
@app.post('/admin/importar-precos')
def acionar_importacao():
    """
    Aciona manualmente a rotina de importação de preços para todas as integrações ativas.
    """
    try:
        importar_todos_precos()
        return {"success": True, "message": "Importação executada."}
    except Exception as e:
        return {"success": False, "message": str(e)}

@app.get('/admin/importar-precos/logs')
def get_import_logs():
    """
    Retorna os últimos logs de importação de preços.
    """
    return {"logs": _import_logs[-50:]}

# Endpoints de integração de preços
@app.get('/admin/integracoes')
def listar_integracoes(loja_id: int = Query(None)):
    """
    Lista integrações de preço cadastradas. Se loja_id for informado, filtra por loja.
    """
    return get_integrations(loja_id)



@app.post('/admin/integracoes')
def salvar_integracao(data: dict = Body(...)):
    """
    Adiciona ou atualiza uma integração de preço para uma loja ou global, incluindo layout do arquivo.
    """
    from integration_config import update_integration_by_id
    id_ = data.get('id')
    loja_id = data.get('loja_id')
    tipo = data.get('tipo')
    parametro1 = data.get('parametro1')
    parametro2 = data.get('parametro2')
    ativo = data.get('ativo', 1)
    layout = data.get('layout')
    # Validação básica
    if not tipo or not parametro1:
        return {"success": False, "message": "Campos obrigatórios: tipo e parametro1"}
    if id_ is not None:
        # Atualiza pelo id
        update_integration_by_id(id_, loja_id, tipo, parametro1, parametro2, ativo, layout)
    else:
        # Insere ou atualiza por (loja_id, tipo)
        upsert_integration(loja_id, tipo, parametro1, parametro2, ativo, layout)
    return {"success": True}

@app.post('/admin/devices/register')
async def register_device_by_store_code(request: Request):
    data = await request.json()
    store_codigo = data.get('store_codigo')
    name = data.get('name')
    identifier = data.get('identifier')
    if not store_codigo or not name or not identifier:
        return {"success": False, "message": "Todos os campos são obrigatórios (store_codigo, name, identifier)."}
    from database import get_store_by_code, add_device
    store = get_store_by_code(str(store_codigo).strip())
    if not store:
        return {"success": False, "message": f"Loja com código {store_codigo} não encontrada."}
    store_id = store['id']
    add_device(store_id, name, identifier=identifier)
    return {"success": True, "message": "Equipamento registrado com sucesso."}


BANNERS_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), 'banners'))
os.makedirs(BANNERS_DIR, exist_ok=True)
import logging

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    username = verify_access_token(token)
    if not username:
        raise HTTPException(status_code=401, detail="Token inválido ou expirado")
    return username

@app.get('/admin/status')
@app.get('/admin/status')
def admin_status():
    status = get_system_status()
    # Determina status online: se existe pelo menos 1 device online
    devices = get_all_devices()
    online = any([d.get('online') for d in devices])
    # Busca último backup
    try:
        from backup_restore import get_last_backup
        backup = get_last_backup()
        last_backup = backup['timestamp'] if backup and 'timestamp' in backup else None
    except Exception:
        last_backup = None
    status['online'] = online
    status['last_backup'] = last_backup
    return JSONResponse(content=status)

# Endpoint para servir favicon.ico
@app.get('/favicon.ico')
def favicon():
    file_path = os.path.join(FRONTEND_PUBLIC_DIR, 'favicon.ico')
    if os.path.exists(file_path):
        return FileResponse(file_path)
    raise HTTPException(status_code=404, detail='favicon not found')

# Endpoint simples de healthcheck para monitoramento
@app.get('/health')
def health():
    return {"status": "ok"}


# Inicializa o banco de dados e popula com dados de exemplo ao iniciar o app
@app.on_event("startup")
def startup():
    init_db()
    populate_example_data()

@app.get("/status")
async def system_status():
    # Verifica o status do sistema
    status = get_system_status()
    return JSONResponse(content=status)

@app.post("/notify-ai-agent/")
async def notify_agent(request: Request):
    # Notifica o agente AI sobre uma nova requisição
    data = await request.json()
    response = notify_ai_agent(data)
    return JSONResponse(content=response)

# Resto dos endpoints e lógica da aplicação... (continua com todo o conteúdo do main_backup_20250730.py, linha a linha, até o final)

# Endpoint para listar banners filtrando por loja
from fastapi import Query
@app.get('/admin/banners')
def list_banners(store_id: str = Query(None)):
    files = [f for f in os.listdir(BANNERS_DIR) if f.lower().endswith((".jpg", ".jpeg", ".png", ".gif", ".webp"))]
    meta_path = os.path.join(BANNERS_DIR, 'banners_meta.json')
    meta = {}
    if os.path.exists(meta_path):
        try:
            with open(meta_path, 'r', encoding='utf-8') as f:
                meta = json.load(f)
        except Exception:
            meta = {}
    filtered = []
    import logging
    logging.info(f"[BANNERS] list_banners chamado com store_id={store_id}")
    for f in files:
        m = meta.get(f, {})
        # Padroniza store_id: sempre string, sem espaços
        meta_store_id = str(m.get('store_id')).strip() if m.get('store_id') is not None else None
        req_store_id = str(store_id).strip() if store_id is not None else None
        all_stores_flag = bool(m.get('all_stores'))
        logging.info(f"[BANNERS][DEBUG] Banner: {f} | meta_store_id: '{meta_store_id}' | req_store_id: '{req_store_id}' | all_stores: {all_stores_flag}")
        if all_stores_flag:
            filtered.append({"filename": f, "url": f"/admin/banners/{f}"})
        elif req_store_id and meta_store_id and meta_store_id == req_store_id:
            filtered.append({"filename": f, "url": f"/admin/banners/{f}"})
    logging.info(f"[BANNERS] Retornando {len(filtered)} banners para store_id={store_id}")
    return filtered


# Endpoint para receber atualizações em lote (bulk) de produtos
@app.post('/admin/products/bulk')
def admin_products_bulk(payload: List[Dict] = Body(...), username: str = Depends(get_current_user)):
    """Recebe uma lista de produtos e faz upsert no banco local.

    Requer autenticação via token Bearer (get_current_user).
    """
    try:
        # valida formato
        if not isinstance(payload, list):
            raise HTTPException(status_code=400, detail='Payload deve ser uma lista de produtos')
        result = upsert_products(payload)
        # registra auditoria
        try:
            add_audit_log(None, None, 'PRODUCTS_BULK_UPSERT', json.dumps({'user': username, 'result': result}, ensure_ascii=False))
        except Exception:
            pass
        return JSONResponse(content={'success': True, 'result': result})
    except HTTPException:
        raise
    except Exception as e:
        logging.exception('Erro no endpoint admin/products/bulk')
        raise HTTPException(status_code=500, detail=str(e))

# Endpoint para servir banner individual
@app.get('/admin/banners/{filename}')
def get_banner(filename: str):
    file_path = os.path.join(BANNERS_DIR, filename)
    if not os.path.exists(file_path):
        return {"success": False, "message": "Arquivo não encontrado."}
    return FileResponse(file_path)

# Endpoint para deletar banner
@app.delete('/admin/banners/{filename}')
def delete_banner(filename: str):
    file_path = os.path.join(BANNERS_DIR, filename)
    if os.path.exists(file_path):
        os.remove(file_path)
        return {"success": True}
    return {"success": False, "message": "Arquivo não encontrado."}

# Endpoint para fazer upload de banner




@app.post('/admin/banners/upload')
async def upload_banner(request: Request, username: str = Depends(get_current_user)):
    import logging
    form = await request.form()
    file = form.get('file')
    store_id = form.get('store_id')
    all_stores = form.get('all_stores')
    logging.info(f"[UPLOAD] username={username} file={getattr(file, 'filename', None)} store_id={store_id} all_stores={all_stores}")
    # Validação: arquivo obrigatório
    if not file or not hasattr(file, 'filename'):
        logging.error("[UPLOAD] Falta arquivo de imagem.")
        raise HTTPException(status_code=400, detail="Arquivo de imagem obrigatório.")
    file_ext = os.path.splitext(file.filename)[1].lower()
    if file_ext not in ['.jpg', '.jpeg', '.png', '.gif', '.webp']:
        logging.error(f"[UPLOAD] Formato não suportado: {file_ext}")
        raise HTTPException(status_code=400, detail="Formato de arquivo não suportado.")
    if not store_id and not all_stores:
        logging.error("[UPLOAD] Falta store_id e all_stores.")
        raise HTTPException(status_code=400, detail="É obrigatório informar a loja ou marcar 'todas as lojas'.")
    # Salva arquivo
    file_path = os.path.join(BANNERS_DIR, file.filename)
    try:
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        logging.info(f"[UPLOAD] Arquivo salvo em {file_path}")
    except Exception as e:
        logging.error(f"[UPLOAD] Erro ao salvar arquivo: {e}")
        raise HTTPException(status_code=500, detail="Erro ao salvar arquivo.")
    # Salva metadados do banner
    meta_path = os.path.join(BANNERS_DIR, 'banners_meta.json')
    try:
        if os.path.exists(meta_path):
            with open(meta_path, 'r', encoding='utf-8') as f:
                meta = json.load(f)
        else:
            meta = {}
    except Exception as e:
        logging.error(f"[UPLOAD] Erro ao ler banners_meta.json: {e}")
        meta = {}
    # Padroniza store_id para string limpa
    store_id_clean = str(store_id).strip() if store_id else None
    all_stores_flag = str(all_stores).lower() in ['1', 'true', 'on', 'yes'] if all_stores is not None else False
    logging.info(f"[UPLOAD][DEBUG] Salvando banner: {getattr(file, 'filename', None)} | store_id: '{store_id}' | store_id_clean: '{store_id_clean}' | all_stores: {all_stores_flag} | uploaded_by: {username}")
    meta[file.filename] = {
        'store_id': store_id_clean,
        'all_stores': all_stores_flag,
        'uploaded_by': username
    }
    try:
        with open(meta_path, 'w', encoding='utf-8') as f:
            json.dump(meta, f, ensure_ascii=False, indent=2)
        logging.info(f"[UPLOAD] Metadados salvos para {file.filename}")
    except Exception as e:
        logging.error(f"[UPLOAD] Erro ao salvar banners_meta.json: {e}")
        raise HTTPException(status_code=500, detail="Erro ao salvar metadados.")
    return {"success": True, "filename": file.filename}

# Configuração básica de logs
logging.basicConfig(level=logging.INFO)

# Permitir CORS em desenvolvimento (frontend separado)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)



@app.on_event('startup')
def startup():
    init_db()
    # Cria usuário admin padrão se não existir nenhum
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT COUNT(*) as total FROM admin_users')
    total = cur.fetchone()['total']
    if total == 0:
        cur.execute('INSERT INTO admin_users (username, password) VALUES (?, ?)', ('admin', 'admin'))
        conn.commit()
        import logging
        logging.info('Usuário admin padrão criado: admin/admin')
    conn.close()
    notify_ai_agent('startup', {'source': 'backend', 'info': 'Backend iniciado'})
    start_ia_healthcheck()  # Inicia monitoramento proativo

# --- Funções auxiliares de automação IA ---
IA_AUTONOMOUS_ACTIONS_LOG = os.path.join(os.path.dirname(__file__), 'logs', 'ia_autonomous_actions.log')
os.makedirs(os.path.dirname(IA_AUTONOMOUS_ACTIONS_LOG), exist_ok=True)

def log_ia_autonomous_action(action, result, details=None):
    entry = {
        'timestamp': datetime.now().isoformat(),
        'action': action,
        'result': result,
        'details': details or {}
    }
    with open(IA_AUTONOMOUS_ACTIONS_LOG, 'a', encoding='utf-8') as f:
        f.write(json.dumps(entry, ensure_ascii=False) + '\n')

def ia_autonomous_check_devices():
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT id, name, identifier, last_sync, online FROM devices')
    now = datetime.now()
    offline_count = 0
    for row in cur.fetchall():
        last_sync = row['last_sync']
        online = row['online']
        if last_sync:
            try:
                last_dt = datetime.fromisoformat(last_sync)
            except Exception:
                continue
            diff = (now - last_dt).total_seconds() / 60
            if diff > 10 and online:
                set_device_offline(row['id'])
                log_ia_autonomous_action(
                    action='set_device_offline',
                    result='success',
                    details={'device_id': row['id'], 'name': row['name'], 'identifier': row['identifier'], 'reason': f'No heartbeat for {diff:.1f} min'}
                )
                notify_ai_agent('device_offline_auto', {'device_id': row['id'], 'name': row['name'], 'identifier': row['identifier'], 'reason': f'No heartbeat for {diff:.1f} min'})
                offline_count += 1
    conn.close()
    return offline_count

def ia_autonomous_cleanup_logs():
    from datetime import datetime, timedelta
    conn = get_db_connection()
    cur = conn.cursor()
    # Remove logs com mais de 30 dias
    limite = (datetime.utcnow() - timedelta(days=30)).isoformat()
    cur.execute('DELETE FROM audit_log WHERE timestamp < ?', (limite,))
    removidos = cur.rowcount
    conn.commit()
    conn.close()
    log_ia_autonomous_action(
        action='cleanup_logs',
        result='success',
        details={'removed_logs': removidos, 'older_than': limite}
    )
    return removidos

def ia_autonomous_fix_product_data():
    conn = get_db_connection()
    cur = conn.cursor()
    # Corrige produtos com nome vazio
    cur.execute("UPDATE products SET name = 'Produto sem nome' WHERE name IS NULL OR TRIM(name) = ''")
    nome_corrigido = cur.rowcount
    # Corrige preços negativos ou nulos
    cur.execute("UPDATE products SET price = 0.01 WHERE price IS NULL OR price <= 0")
    preco_corrigido = cur.rowcount
    # Corrige promoções inconsistentes (promo nulo vira string vazia)
    cur.execute("UPDATE products SET promo = '' WHERE promo IS NULL")
    promo_corrigido = cur.rowcount
    conn.commit()
    conn.close()
    total = nome_corrigido + preco_corrigido + promo_corrigido
    log_ia_autonomous_action(
        action='fix_product_data',
        result='success',
        details={'name_fixed': nome_corrigido, 'price_fixed': preco_corrigido, 'promo_fixed': promo_corrigido}
    )
    return total

def ia_autonomous_fix_outlier_prices():
    conn = get_db_connection()
    cur = conn.cursor()
    # Busca todos os preços válidos
    cur.execute("SELECT price FROM products WHERE price IS NOT NULL AND price > 0 ORDER BY price")
    prices = [row['price'] for row in cur.fetchall()]
    if not prices:
        conn.close()
        return 0
    # Calcula mediana
    n = len(prices)
    if n % 2 == 1:
        mediana = prices[n // 2]
    else:
        mediana = (prices[n // 2 - 1] + prices[n // 2]) / 2
    # Define limites de outlier (ex: 10x acima ou 0.1x abaixo da mediana)
    limite_sup = mediana * 10
    limite_inf = mediana * 0.1
    # Corrige preços muito altos
    cur.execute("UPDATE products SET price = ? WHERE price > ?", (limite_sup, limite_sup))
    acima = cur.rowcount
    # Corrige preços muito baixos (mas > 0)
    cur.execute("UPDATE products SET price = ? WHERE price < ? AND price > 0", (limite_inf, limite_inf))
    abaixo = cur.rowcount
    conn.commit()
    conn.close()
    total = acima + abaixo
    log_ia_autonomous_action(
        action='fix_outlier_prices',
        result='success',
        details={'fixed_above': acima, 'fixed_below': abaixo, 'median': mediana, 'limit_sup': limite_sup, 'limit_inf': limite_inf}
    )
    return total

# --- IA Monitoramento Proativo e Otimização do Sistema ---
HEALTHCHECK_ENDPOINTS = [
    '/admin/status',
    '/admin/devices',
    '/admin/stores',
    '/product/all',
    '/health'
]

HEALTHCHECK_LOG = os.path.join(os.path.dirname(__file__), 'logs', 'healthcheck.log')
os.makedirs(os.path.dirname(HEALTHCHECK_LOG), exist_ok=True)

# Função para checar endpoints periodicamente
def ia_healthcheck_loop():
    while True:
        results = []
        for ep in HEALTHCHECK_ENDPOINTS:
            try:
                url = f'http://127.0.0.1:8000{ep}'
                r = requests.get(url, timeout=5)
                status = r.status_code
                ok = status == 200
            except Exception as e:
                ok = False
                status = str(e)
            results.append({'endpoint': ep, 'ok': ok, 'status': status, 'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S')})
        # Loga resultado
        with open(HEALTHCHECK_LOG, 'a', encoding='utf-8') as f:
            for res in results:
                f.write(json.dumps(res, ensure_ascii=False) + '\n')
        # Notifica IA se algum endpoint falhar
        for res in results:
            if not res['ok']:
                notify_ai_agent('healthcheck_fail', res)
        # Executa automações autônomas da IA a cada ciclo
        try:
            ia_autonomous_execute_all()
        except Exception as e:
            log_ia_autonomous_action('autonomous_execute', 'fail', {'error': str(e)})
        time.sleep(60)  # roda a cada 1 min

def start_ia_healthcheck():
    t = threading.Thread(target=ia_healthcheck_loop, daemon=True)
    t.start()

OPTIMIZATION_LOG = os.path.join(os.path.dirname(__file__), 'logs', 'optimization_suggestions.log')

def ia_analyze_logs_and_optimize():
    # Exemplo: IA analisa healthcheck.log e sugere melhorias
    if not os.path.exists(HEALTHCHECK_LOG):
        return
    with open(HEALTHCHECK_LOG, 'r', encoding='utf-8') as f:
        lines = f.readlines()[-100:]
    issues = [json.loads(l) for l in lines if not json.loads(l)['ok']]
    if issues:
        suggestion = {
            'timestamp': time.strftime('%Y-%m-%dT%H:%M:%S'),
            'suggestion': f"Foram detectados {len(issues)} falhas recentes em endpoints. Recomenda-se revisar logs e infraestrutura.",
            'issues': issues
        }
        with open(OPTIMIZATION_LOG, 'a', encoding='utf-8') as f:
            f.write(json.dumps(suggestion, ensure_ascii=False) + '\n')
        notify_ai_agent('optimization_suggestion', suggestion)

@app.get('/admin/ia-health-dashboard')
def ia_health_dashboard():
    # Últimos healthchecks
    health = []
    if os.path.exists(HEALTHCHECK_LOG):
        with open(HEALTHCHECK_LOG, 'r', encoding='utf-8') as f:
            health = [json.loads(l) for l in f.readlines()[-20:]]
    # Últimas sugestões de otimização
    optim = []
    if os.path.exists(OPTIMIZATION_LOG):
        with open(OPTIMIZATION_LOG, 'r', encoding='utf-8') as f:
            optim = [json.loads(l) for l in f.readlines()[-10:]]
    return {
        'healthchecks': health,
        'optimizations': optim
    }

@app.post('/admin/ia-analyze-logs')
def ia_analyze_logs_endpoint():
    ia_analyze_logs_and_optimize()
    return {'success': True, 'message': 'Análise de logs e sugestão de otimização executada.'}

@app.on_event('startup')
def startup():
    init_db()
    # Cria usuário admin padrão se não existir nenhum
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT COUNT(*) as total FROM admin_users')
    total = cur.fetchone()['total']
    if total == 0:
        cur.execute('INSERT INTO admin_users (username, password) VALUES (?, ?)', ('admin', 'admin'))
        conn.commit()
        import logging
        logging.info('Usuário admin padrão criado: admin/admin')
    conn.close()
    notify_ai_agent('startup', {'source': 'backend', 'info': 'Backend iniciado'})
    start_ia_healthcheck()  # Inicia monitoramento proativo

# Endpoint para retornar todos os produtos (para sync do frontend)
@app.get('/product/all')
def get_all_products():
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT barcode, name, price, promo FROM products')
    rows = cur.fetchall()
    conn.close()
    # Corrige preço para reais se estiver em centavos
    produtos = []
    for row in rows:
        produto = dict(row)
        preco = produto['price']
        # Se o preço for menor que 1 e não for zero, provavelmente está em centavos
        if preco and preco < 1:
            produto['price'] = round(preco * 100, 2)
        produtos.append(produto)
    notify_ai_agent('sync_success', {'source': 'backend', 'info': 'Produtos sincronizados'})
    return produtos



# Endpoint de login admin
from fastapi.responses import JSONResponse
@app.post('/admin/login')
async def admin_login(request: Request):
    data = await request.json()
    username = data.get('username')
    password = data.get('password')
    if not username or not password:
        return JSONResponse(status_code=400, content={"success": False, "message": "Usuário e senha obrigatórios"})
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT * FROM admin_users WHERE username = ?', (username,))
    user = cur.fetchone()
    conn.close()
    if user and authenticate_admin(username, password):
        role = user['role'] if 'role' in user.keys() else 'admin'
        store_id = user['store_id'] if 'store_id' in user.keys() else None
        permissoes = user['permissoes'] if 'permissoes' in user.keys() else None
        # Converte permissoes de string JSON para array, se necessário
        if permissoes:
            try:
                permissoes = json.loads(permissoes)
            except Exception:
                permissoes = []
        else:
            permissoes = []
        access_token = create_access_token({"sub": username, "role": role})
        # Busca o codigo da loja se houver store_id
        store_codigo = None
        if store_id:
            from database import get_store_by_code
            store = None
            try:
                store = get_store_by_code(store_id) if isinstance(store_id, str) and not store_id.isdigit() else None
                if not store:
                    # store_id pode ser int, buscar por id
                    conn2 = get_db_connection()
                    cur2 = conn2.cursor()
                    cur2.execute('SELECT codigo FROM stores WHERE id = ?', (store_id,))
                    row = cur2.fetchone()
                    conn2.close()
                    if row:
                        store_codigo = row['codigo']
            except Exception:
                store_codigo = None
        return {
            "success": True,
            "access_token": access_token,
            "token_type": "bearer",
            "role": role,
            "store_id": store_id,
            "store_codigo": store_codigo,
            "permissoes": permissoes,
            "username": username
        }
    else:
        return JSONResponse(status_code=401, content={"success": False, "message": "Usuário ou senha inválidos"})

# Função utilitária para checar se usuário é admin
from jose import jwt
SECRET_KEY = "precix_super_secret_key_2025"
ALGORITHM = "HS256"
def require_admin(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get('role') != 'admin':
            raise HTTPException(status_code=403, detail='Acesso restrito a administradores')
    except Exception:
        raise HTTPException(status_code=401, detail='Token inválido ou expirado')

# --- Endpoints de administração de usuários admin ---
from fastapi import Body

@app.get('/admin/users')
def list_admin_users(current_user: str = Depends(require_admin)):
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT username, role, store_id, permissoes FROM admin_users')
    users = []
    for row in cur.fetchall():
        permissoes = row['permissoes'] if 'permissoes' in row.keys() else None
        if permissoes:
            try:
                permissoes = json.loads(permissoes)
            except Exception:
                permissoes = []
        else:
            permissoes = []
        users.append({
            'username': row['username'],
            'role': row['role'] if 'role' in row.keys() else 'admin',
            'store_id': row['store_id'] if 'store_id' in row.keys() else None,
            'permissoes': permissoes
        })
    conn.close()
    return {'users': users}

@app.post('/admin/users')
def create_admin_user_endpoint(data: dict = Body(...), current_user: str = Depends(require_admin)):
    from database import hash_password
    username = data.get('username')
    password = data.get('password')
    role = data.get('role', 'admin')
    if not username or not password:
        raise HTTPException(status_code=400, detail='Usuário e senha obrigatórios')
    hashed = hash_password(password)
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute('INSERT INTO admin_users (username, password, role) VALUES (?, ?, ?)', (username, hashed, role))
        conn.commit()
    except Exception as e:
        conn.close()
        if 'UNIQUE constraint failed' in str(e):
            raise HTTPException(status_code=409, detail='Usuário já existe')
        raise HTTPException(status_code=500, detail='Erro ao criar usuário')
    conn.close()
    return {'success': True, 'message': 'Usuário criado com sucesso'}

@app.put('/admin/users/{username}')
def update_admin_user(username: str, data: dict = Body(...), current_user: str = Depends(require_admin)):
    from database import hash_password
    password = data.get('password')
    role = data.get('role')
    permissoes = data.get('permissoes')
    store_id = data.get('store_id')
    # Garante que permissoes seja string JSON para o banco
    if permissoes is not None and not isinstance(permissoes, str):
        permissoes = json.dumps(permissoes)
    if not password and not role and permissoes is None and store_id is None:
        raise HTTPException(status_code=400, detail='Nada para atualizar')
    conn = get_db_connection()
    cur = conn.cursor()
    # Atualiza todos os campos enviados
    if password and role and permissoes is not None and store_id is not None:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ?, role = ?, permissoes = ?, store_id = ? WHERE username = ?', (hashed, role, permissoes, store_id, username))
    elif password and role and store_id is not None:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ?, role = ?, store_id = ? WHERE username = ?', (hashed, role, store_id, username))
    elif password and permissoes is not None and store_id is not None:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ?, permissoes = ?, store_id = ? WHERE username = ?', (hashed, permissoes, store_id, username))
    elif role and permissoes is not None and store_id is not None:
        cur.execute('UPDATE admin_users SET role = ?, permissoes = ?, store_id = ? WHERE username = ?', (role, permissoes, store_id, username))
    elif password and store_id is not None:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ?, store_id = ? WHERE username = ?', (hashed, store_id, username))
    elif role and store_id is not None:
        cur.execute('UPDATE admin_users SET role = ?, store_id = ? WHERE username = ?', (role, store_id, username))
    elif permissoes is not None and store_id is not None:
        cur.execute('UPDATE admin_users SET permissoes = ?, store_id = ? WHERE username = ?', (permissoes, store_id, username))
    elif store_id is not None:
        cur.execute('UPDATE admin_users SET store_id = ? WHERE username = ?', (store_id, username))
    elif password and role and permissoes is not None:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ?, role = ?, permissoes = ? WHERE username = ?', (hashed, role, permissoes, username))
    elif password and role:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ?, role = ? WHERE username = ?', (hashed, role, username))
    elif password and permissoes is not None:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ?, permissoes = ? WHERE username = ?', (hashed, permissoes, username))
    elif role and permissoes is not None:
        cur.execute('UPDATE admin_users SET role = ?, permissoes = ? WHERE username = ?', (role, permissoes, username))
    elif password:
        hashed = hash_password(password)
        cur.execute('UPDATE admin_users SET password = ? WHERE username = ?', (hashed, username))
    elif role:
        cur.execute('UPDATE admin_users SET role = ? WHERE username = ?', (role, username))
    elif permissoes is not None:
        cur.execute('UPDATE admin_users SET permissoes = ? WHERE username = ?', (permissoes, username))
    if cur.rowcount == 0:
        conn.close()
        raise HTTPException(status_code=404, detail='Usuário não encontrado')
    conn.commit()
    conn.close()
    return {'success': True, 'message': 'Usuário atualizado com sucesso'}

@app.delete('/admin/users/{username}')
def delete_admin_user(username: str, current_user: str = Depends(require_admin)):
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('DELETE FROM admin_users WHERE username = ?', (username,))
    if cur.rowcount == 0:
        conn.close()
        raise HTTPException(status_code=404, detail='Usuário não encontrado')
    conn.commit()
    conn.close()
    return {'success': True, 'message': 'Usuário removido com sucesso'}

# Endpoint para buscar produto pelo código de barras
@app.get('/product/{barcode}')
def get_product(barcode: str):
    product = get_product_by_barcode(barcode)
    if not product:
        raise HTTPException(status_code=404, detail='Produto não encontrado')
    return product


# Serve o frontend (build) se existir, mas não impede execução separada
def mount_frontend_if_exists():
    FRONTEND_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'frontend', 'dist'))
    if os.path.exists(FRONTEND_PATH):
        logging.info(f"Montando frontend na pasta: {FRONTEND_PATH}")
        mount_frontend(app, FRONTEND_PATH)
    else:
        logging.warning(f"Pasta {FRONTEND_PATH} não encontrada. Certifique-se de que o build do frontend foi gerado corretamente.")

mount_frontend_if_exists()

# Endpoints de lojas
@app.get('/admin/stores')
def api_get_stores():
    return get_all_stores()

@app.post('/admin/stores')
async def api_add_store(request: Request):
    data = await request.json()
    name = data.get('name')
    if not name:
        return {"success": False, "message": "Nome da loja obrigatório."}
    add_store(name)
    return {"success": True}

@app.put('/admin/stores/{store_id}')
def api_update_store(store_id: int, name: str, status: str):
    update_store(store_id, name, status)
    return {"success": True}

@app.delete('/admin/stores/{store_id}')
def api_delete_store(store_id: int):
    delete_store(store_id)
    return {"success": True}

# Endpoints de equipamentos
@app.get('/admin/devices')
def api_get_devices():
    return get_all_devices()

@app.post('/admin/devices')
async def api_add_device(request: Request):
    data = await request.json()
    store_id = data.get('store_id')
    name = data.get('name')
    identifier = data.get('identifier')
    if not store_id or not name or not identifier:
        return {"success": False, "message": "Todos os campos são obrigatórios."}
    # Adiciona dispositivo já com o identifier correto
    add_device(store_id, name, identifier=identifier)
    notify_ai_agent('device_added', {'store_id': store_id, 'name': name, 'identifier': identifier})
    return {"success": True}

@app.put('/admin/devices/{device_id}')
def api_update_device(device_id: int, name: str, status: str, last_sync: str = None, online: int = None):
    update_device(device_id, name, status, last_sync, online)
    return {"success": True}

@app.delete('/admin/devices/{device_id}')
def api_delete_device(device_id: int):
    delete_device(device_id)
    return {"success": True}

# Endpoint heartbeat: equipamento envia ping para marcar online
@app.post('/device/heartbeat/{identifier}')
def device_heartbeat(identifier: str):
    # Busca o device pelo identificador (UUID)
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute('SELECT id FROM devices WHERE identifier = ?', (identifier,))
    row = cur.fetchone()
    conn.close()
    if not row:
        # Tenta buscar por identifier ignorando case e espaços
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute('SELECT id FROM devices WHERE TRIM(LOWER(identifier)) = ?', (identifier.strip().lower(),))
        row = cur.fetchone()
        conn.close()
        if not row:
            raise HTTPException(status_code=404, detail='Dispositivo não encontrado')
    # Corrigido: passa identifier para set_device_online
    set_device_online(identifier)
    notify_ai_agent('device_heartbeat', {'identifier': identifier})
    return {"success": True}

# Endpoint para exportar produtos para .txt
@app.get('/admin/export-txt')
def export_txt():
    txt_path = export_products_to_txt()
    notify_ai_agent('export', {'file': txt_path})
    return FileResponse(txt_path, media_type='text/plain', filename='produtos.txt')

# Endpoints de auditoria
@app.get('/admin/audit-logs')
def api_get_audit_logs(limit: int = 50):
    """Retorna logs de auditoria gerais do sistema"""
    return get_audit_logs(limit)

@app.get('/admin/devices/{device_id}/audit-logs')
def api_get_device_audit_logs(device_id: int, limit: int = 20):
    """Retorna logs de auditoria específicos de um dispositivo"""
    return get_device_audit_logs(device_id, limit)


# Endpoint para deletar integração
@app.delete('/admin/integracoes/{integracao_id}')
def deletar_integracao(integracao_id: int):
    from integration_config import delete_integration
    try:
        delete_integration(integracao_id)
        return {"success": True}
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

@app.post('/admin/agents/status')
def update_agent_status(data: dict = Body(...)):
    # Aceita payloads com 'agent_id' ou 'id' (compatibilidade com agente local)
    agent_id = data.get('agent_id') or data.get('id') or data.get('agentId')
    status = data.get('status') or data.get('state')
    info = data.get('info', {}) or data.get('details', {})
    if not agent_id or not status:
        raise HTTPException(status_code=400, detail='agent_id (ou id) e status obrigatórios')
    AGENTS_STATUS[agent_id] = {'status': status, 'info': info, 'timestamp': datetime.now().isoformat()}
    return {'success': True}